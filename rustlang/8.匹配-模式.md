# åŒ¹é…

ä¸€ä¸ªç®€å•çš„[`if`](If Ifè¯­å¥.md)/`else`å¾€å¾€æ˜¯ä¸å¤Ÿçš„ï¼Œå› ä¸ºä½ å¯èƒ½æœ‰ä¸¤ä¸ªæˆ–æ›´å¤šä¸ªé€‰é¡¹ã€‚è¿™æ ·`else`ä¹Ÿä¼šå˜å¾—å¼‚å¸¸å¤æ‚ã€‚Rust æœ‰ä¸€ä¸ª`match`å…³é”®å­—ï¼Œå®ƒå¯ä»¥è®©ä½ æœ‰æ•ˆçš„å–ä»£å¤æ‚çš„`if`/`else`ç»„ã€‚çœ‹çœ‹ä¸‹é¢çš„ä»£ç ï¼š

```rust
let x = 5;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    4 => println!("four"),
    5 => println!("five"),
    _ => println!("something else"),
}
```

`match`ä½¿ç”¨ä¸€ä¸ªè¡¨è¾¾å¼ç„¶ååŸºäºå®ƒçš„å€¼åˆ†æ”¯ã€‚æ¯ä¸ªåˆ†æ”¯éƒ½æ˜¯`val => expression`è¿™ç§å½¢å¼ã€‚å½“åŒ¹é…åˆ°ä¸€ä¸ªåˆ†æ”¯ï¼Œå®ƒçš„è¡¨è¾¾å¼å°†è¢«æ‰§è¡Œã€‚`match`å±äºâ€œæ¨¡å¼åŒ¹é…â€çš„èŒƒç•´ï¼Œ`match`æ˜¯å®ƒçš„ä¸€ä¸ªå®ç°ã€‚æœ‰[ä¸€ä¸ªæ•´ä¸ªå…³äºæ¨¡å¼çš„éƒ¨åˆ†](Patterns æ¨¡å¼.md)è®²åˆ°äº†æ‰€æœ‰å¯èƒ½çš„æ¨¡å¼ã€‚

é‚£ä¹ˆè¿™æœ‰ä»€ä¹ˆå·¨å¤§çš„ä¼˜åŠ¿å‘¢ï¼Ÿè¿™ç¡®å®æœ‰ä¼˜åŠ¿ã€‚ç¬¬ä¸€ï¼Œ`match`å¼ºåˆ¶*ç©·å°½æ€§æ£€æŸ¥*ï¼ˆ*exhaustiveness checking*ï¼‰ã€‚ä½ çœ‹åˆ°äº†æœ€åé‚£ä¸ªä¸‹åˆ’çº¿å¼€å¤´çš„åˆ†æ”¯äº†å—ï¼Ÿå¦‚æœå»æ‰å®ƒï¼ŒRust å°†ä¼šç»™æˆ‘ä»¬ä¸€ä¸ªé”™è¯¯ï¼š

```text
error: non-exhaustive patterns: `_` not covered
```

Rust è¯•å›¾å‘Šè¯‰æˆ‘ä»¬å¿˜è®°äº†ä¸€ä¸ªå€¼ã€‚ç¼–è¯‘å™¨ä»`x`æ¨æ–­å®ƒå¯ä»¥æ˜¯ä»»ä½•æ­£çš„ 32 ä½æ•´å‹å€¼ï¼›ä¾‹å¦‚ä» 1 åˆ° 2,147,483,647ã€‚`_`å°±åƒä¸€ä¸ª*åŒ¹é…æ‰€æœ‰*çš„åˆ†æ”¯ï¼Œå®ƒä¼šæ•è·æ‰€æœ‰æ²¡æœ‰è¢«`match`åˆ†æ”¯æ•è·çš„æ‰€æœ‰å¯èƒ½å€¼ã€‚å¦‚ä½ æ‰€è§ï¼Œåœ¨ä¸Šä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æä¾›äº† 1 åˆ° 5 çš„`mtach`åˆ†æ”¯ï¼Œå¦‚æœ`x`æ˜¯ 6 æˆ–è€…å…¶ä»–å€¼ï¼Œé‚£ä¹ˆå®ƒä¼šè¢«`_`æ•è·ã€‚

`match`ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒå¯ä»¥ç”¨åœ¨`let`ç»‘å®šçš„å³ä¾§æˆ–è€…å…¶å®ƒç›´æ¥ç”¨åˆ°è¡¨è¾¾å¼çš„åœ°æ–¹ï¼š

```rust
let x = 5;

let number = match x {
    1 => "one",
    2 => "two",
    3 => "three",
    4 => "four",
    5 => "five",
    _ => "something else",
};
```

æœ‰æ—¶ï¼Œè¿™æ˜¯ä¸€ä¸ªæŠŠä¸€ç§ç±»å‹çš„æ•°æ®è½¬æ¢ä¸ºå¦ä¸€ä¸ªç±»å‹çš„å¥½æ–¹æ³•ã€‚

## åŒ¹é…æšä¸¾ï¼ˆMatching on enumsï¼‰
`match`çš„å¦ä¸€ä¸ªé‡è¦çš„ä½œç”¨æ˜¯å¤„ç†æšä¸¾çš„å¯èƒ½å˜é‡ï¼š

```rust
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit => quit(),
        Message::ChangeColor(r, g, b) => change_color(r, g, b),
        Message::Move { x: x, y: y } => move_cursor(x, y),
        Message::Write(s) => println!("{}", s),
    };
}
```

å†ä¸€æ¬¡ï¼ŒRustç¼–è¯‘å™¨æ£€æŸ¥ç©·å°½æ€§ï¼Œæ‰€ä»¥å®ƒè¦æ±‚å¯¹æ¯ä¸€ä¸ªæšä¸¾çš„å˜é‡éƒ½æœ‰ä¸€ä¸ªåŒ¹é…åˆ†æ”¯ã€‚å¦‚æœä½ å¿½ç•¥äº†ä¸€ä¸ªï¼Œé™¤éä½ ç”¨`_`å¦åˆ™å®ƒä¼šç»™ä½ ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯ã€‚

ä¸ä¹‹å‰çš„`match`çš„ä½œç”¨ä¸åŒï¼Œä½ ä¸èƒ½ç”¨å¸¸è§„çš„`if`è¯­å¥æ¥åšè¿™äº›ã€‚ä½ å¯ä»¥ä½¿ç”¨[if let](if let.md)è¯­å¥ï¼Œå®ƒå¯ä»¥è¢«çœ‹ä½œæ˜¯ä¸€ä¸ª`match`çš„ç®€ç•¥å½¢å¼ã€‚

# æ¨¡å¼

æ¨¡å¼åœ¨Rustä¸­ååˆ†å¸¸è§ã€‚æˆ‘ä»¬åœ¨[å˜é‡ç»‘å®š](Variable Bindings å˜é‡ç»‘å®š.md)ï¼Œ[åŒ¹é…è¯­å¥](Match åŒ¹é….md)å’Œå…¶å®ƒä¸€äº›åœ°æ–¹ä½¿ç”¨å®ƒä»¬ã€‚è®©æˆ‘ä»¬å¼€å§‹ä¸€ä¸ªå¿«é€Ÿçš„å…³äºæ¨¡å¼å¯ä»¥å¹²ä»€ä¹ˆçš„æ•™ç¨‹ï¼

å¿«é€Ÿå›é¡¾ï¼šä½ å¯ä»¥ç›´æ¥åŒ¹é…å¸¸é‡ï¼Œå¹¶ä¸”`_`ä½œä¸ºâ€œä»»ä½•â€ç±»å‹ï¼š

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

è¿™ä¼šæ‰“å°å‡º`one`ã€‚

æœ‰ä¸€ä¸ªæ¨¡å¼çš„é™·é˜±ï¼šå°±åƒä»»ä½•å¼•å…¥ä¸€ä¸ªæ–°ç»‘å®šçš„è¯­å¥ï¼Œä»–ä»¬ä¼šå¼•å…¥éšè—ã€‚ä¾‹å¦‚ï¼š

```rust
let x = 1;
let c = 'c';

match c {
    x => println!("x: {} c: {}", x, c),
}

println!("x: {}", x)
```

è¿™ä¼šæ‰“å°ï¼š

```text
x: c c: c
x: 1
```

æ¢å¥è¯è¯´ï¼Œ`x =>`åŒ¹é…åˆ°äº†æ¨¡å¼å¹¶å¼•å…¥äº†ä¸€ä¸ªå«åš`x`çš„æ–°ç»‘å®šã€‚è¿™ä¸ªæ–°ç»‘å®šçš„ä½œç”¨åŸŸæ˜¯åŒ¹é…åˆ†æ”¯å¹¶æ‹¥æœ‰`c`çš„å€¼ã€‚æ³¨æ„åŒ¹é…ä½œç”¨åŸŸå¤–çš„`x`çš„å€¼å¯¹å†…éƒ¨çš„`x`çš„å€¼å¹¶æ— å½±å“ã€‚å› ä¸ºæˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ª`x`ï¼Œæ–°çš„`x`éšè—äº†å®ƒã€‚

## å¤šé‡æ¨¡å¼ï¼ˆMultiple patternsï¼‰

ä½ å¯ä»¥ä½¿ç”¨`|`åŒ¹é…å¤šä¸ªæ¨¡å¼ï¼š

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

è¿™ä¼šè¾“å‡º`one or two`ã€‚

## è§£æ„ï¼ˆDestructuringï¼‰
å¦‚æœä½ æœ‰ä¸€ä¸ªå¤åˆæ•°æ®ç±»å‹ï¼Œä¾‹å¦‚ä¸€ä¸ª[ç»“æ„ä½“](Structs ç»“æ„ä½“.md)ï¼Œä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­è§£æ„å®ƒï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } => println!("({},{})", x, y),
}
```

æˆ‘ä»¬å¯ä»¥ç”¨`:`æ¥ç»™å‡ºä¸€ä¸ªä¸åŒçš„åå­—ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } => println!("({},{})", x1, y1),
}
```

å¦‚æœä½ åªå…³å¿ƒéƒ¨åˆ†å€¼ï¼Œæˆ‘ä»¬ä¸éœ€è¦ç»™å®ƒä»¬éƒ½å‘½åï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

è¿™ä¼šè¾“å‡º`x is 0`ã€‚

ä½ å¯ä»¥å¯¹ä»»ä½•æˆå‘˜è¿›è¡Œè¿™æ ·çš„åŒ¹é…ï¼Œä¸ä»…ä»…æ˜¯ç¬¬ä¸€ä¸ªï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y, .. } => println!("y is {}", y),
}
```

è¿™ä¼šè¾“å‡º`y is 0`ã€‚

è¿™ç§â€œè§£æ„â€è¡Œä¸ºå¯ä»¥ç”¨åœ¨ä»»ä½•å¤åˆæ•°æ®ç±»å‹ä¸Šï¼Œä¾‹å¦‚[å…ƒç»„](Primitive Types åŸç”Ÿç±»å‹.md#å…ƒç»„ï¼ˆtuplesï¼‰)å’Œ[æšä¸¾](Enums æšä¸¾.md)

## å¿½ç•¥ç»‘å®šï¼ˆIgnoring bindingsï¼‰

ä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­ä½¿ç”¨`_`æ¥å¿½è§†å®ƒçš„ç±»å‹å’Œå€¼ã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯ä¸€ä¸ª`Result<T, E>`çš„`match`ï¼š

```rust
# let some_value: Result<i32, &'static str> = Err("There was an error");
match some_value {
    Ok(value) => println!("got a value: {}", value),
    Err(_) => println!("an error occurred"),
}
```

åœ¨ç¬¬ä¸€ä¸ªåˆ†æ”¯ï¼Œæˆ‘ä»¬ç»‘å®šäº†`Ok`å˜é‡ä¸­çš„å€¼ä¸º`value`ï¼Œä¸è¿‡åœ¨`Err`åˆ†æ”¯ï¼Œæˆ‘ä»¬ç”¨`_`æ¥å¿½è§†ç‰¹å®šçš„é”™è¯¯ï¼Œè€Œåªæ˜¯æ‰“å°äº†ä¸€ä¸ªé€šç”¨çš„é”™è¯¯ä¿¡æ¯ã€‚

`_`åœ¨ä»»ä½•åˆ›å»ºç»‘å®šçš„æ¨¡å¼ä¸­éƒ½æœ‰æ•ˆã€‚è¿™åœ¨å¿½ç•¥ä¸€ä¸ªå¤§å¤§ç»“æ„ä½“çš„éƒ¨åˆ†å­—æ®µæ—¶å¾ˆæœ‰ç”¨ï¼š

```rust
fn coordinate() -> (i32, i32, i32) {
    // generate and return some sort of triple tuple
# (1, 2, 3)
}

let (x, _, z) = coordinate();
```

è¿™é‡Œï¼Œæˆ‘ä»¬ç»‘å®šå…ƒç»„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå…ƒç´ ä¸º`x`å’Œ`z`ï¼Œä¸è¿‡çœç•¥äº†ä¸­é—´çš„å…ƒç´ ã€‚

ç›¸ä¼¼çš„ï¼Œä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­ç”¨`..`æ¥å¿½ç•¥å¤šä¸ªå€¼ã€‚

```rust
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) => println!("Got a tuple!"),
    OptionalTuple::Missing => println!("No such luck."),
}
```

è¿™ä¼šæ‰“å°`Got a tuple!`ã€‚

## `ref`å’Œ`ref mut`
å¦‚æœä½ æƒ³è¦ä¸€ä¸ªå¼•ç”¨ï¼Œä½¿ç”¨`ref`å…³é”®å­—ï¼š

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r),
}
```

è¿™ä¼šè¾“å‡º`Got a reference to 5`ã€‚

è¿™é‡Œï¼Œ`match`ä¸­çš„`r`æ˜¯`&i32`ç±»å‹çš„ã€‚æ¢å¥è¯è¯´ï¼Œ`ref`å…³é”®å­—åˆ›å»ºäº†ä¸€ä¸ªåœ¨æ¨¡å¼ä¸­ä½¿ç”¨çš„å¼•ç”¨ã€‚å¦‚æœä½ éœ€è¦ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œ`ref mut`åŒæ ·å¯ä»¥åšåˆ°ï¼š

```rust
let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

## èŒƒå›´ï¼ˆRangesï¼‰

ä½ å¯ä»¥ç”¨`...`åŒ¹é…ä¸€ä¸ªèŒƒå›´çš„å€¼ï¼š

```rust
let x = 1;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
```

è¿™ä¼šè¾“å‡º`one through five`ã€‚

èŒƒå›´ç»å¸¸ç”¨åœ¨æ•´æ•°å’Œ`char`ä¸Šã€‚

```rust
let x = 'ğŸ’…';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

è¿™ä¼šè¾“å‡º`something else`ã€‚

## ç»‘å®š

ä½ å¯ä»¥ä½¿ç”¨`@`æŠŠå€¼ç»‘å®šåˆ°åå­—ä¸Šï¼š

```rust
let x = 1;

match x {
    e @ 1 ... 5 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

è¿™ä¼šè¾“å‡º`got a range element 1`ã€‚åœ¨ä½ æƒ³å¯¹ä¸€ä¸ªå¤æ‚æ•°æ®ç»“æ„è¿›è¡Œéƒ¨åˆ†åŒ¹é…çš„æ—¶å€™ï¼Œè¿™ä¸ªç‰¹æ€§ååˆ†æœ‰ç”¨ï¼š

```rust
#[derive(Debug)]
struct Person {
    name: Option<String>,
}

let name = "Steve".to_string();
let mut x: Option<Person> = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) => println!("{:?}", a),
    _ => {}
}
```

è¿™ä¼šè¾“å‡º `Some("Steve")`ï¼Œå› ä¸ºæˆ‘ä»¬æŠŠPersoné‡Œé¢çš„`name`ç»‘å®šåˆ°`a`ã€‚

å¦‚æœä½ åœ¨ä½¿ç”¨`|`çš„åŒæ—¶ä¹Ÿä½¿ç”¨äº†`@`ï¼Œä½ éœ€è¦ç¡®ä¿åå­—åœ¨æ¯ä¸ªæ¨¡å¼çš„æ¯ä¸€éƒ¨åˆ†éƒ½ç»‘å®šåå­—ï¼š

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

## å®ˆå«ï¼ˆGuardsï¼‰
ä½ å¯ä»¥ç”¨`if`æ¥å¼•å…¥*åŒ¹é…å®ˆå«*ï¼ˆ*match guards*ï¼‰ï¼š

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

è¿™ä¼šè¾“å‡º`Got an int!`ã€‚

å¦‚æœä½ åœ¨`if`ä¸­ä½¿ç”¨å¤šé‡æ¨¡å¼ï¼Œ`if`æ¡ä»¶å°†é€‚ç”¨äºæ‰€æœ‰æ¨¡å¼ï¼š

```rust
let x = 4;
let y = false;

match x {
    4 | 5 if y => println!("yes"),
    _ => println!("no"),
}
```

è¿™ä¼šæ‰“å°`no`ï¼Œå› ä¸º`if`é€‚ç”¨äºæ•´ä¸ª` 4 | 5`ï¼Œè€Œä¸ä»…ä»…æ˜¯`5`ï¼Œæ¢å¥è¯è¯´ï¼Œ`if`è¯­å¥çš„ä¼˜å…ˆçº§æ˜¯è¿™æ ·çš„ï¼š

```text
(4 | 5) if y => ...
```

è€Œä¸æ˜¯è¿™æ ·ï¼š

```text
4 | (5 if y) => ...
```

## æ··åˆä¸åŒ¹é…ï¼ˆMix and Matchï¼‰
(å£å“¨)ï¼æ ¹æ®ä½ çš„éœ€æ±‚ï¼Œä½ å¯ä»¥å¯¹ä¸Šé¢çš„å¤šç§åŒ¹é…æ–¹æ³•è¿›è¡Œç»„åˆï¼š

```rust
match x {
    Foo { x: Some(ref name), y: None } => ...
}
```

æ¨¡å¼ååˆ†å¼ºå¤§ã€‚å¥½å¥½ä½¿ç”¨å®ƒä»¬ã€‚

# if let

`if let`å…è®¸ä½ åˆå¹¶`if`å’Œ`let`æ¥å‡å°‘ç‰¹å®šç±»å‹æ¨¡å¼åŒ¹é…çš„å¼€é”€ã€‚

ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰ä¸€äº›`Option<T>`ã€‚æˆ‘ä»¬æƒ³è®©å®ƒæ˜¯`Some<T>`æ—¶åœ¨å…¶ä¸Šè°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œè€Œå®ƒæ˜¯`None`æ—¶ä»€ä¹ˆä¹Ÿä¸åšã€‚è¿™çœ‹èµ·æ¥åƒï¼š

```rust
let option = Some(5);
fn foo(x: i32) { }
match option {
    Some(x) => { foo(x) },
    None => {},
}
```

æˆ‘ä»¬å¹¶ä¸ä¸€å®šè¦åœ¨è¿™ä½¿ç”¨`match`ï¼Œä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`if`ï¼š

```rust
# let option = Some(5);
# fn foo(x: i32) { }
if option.is_some() {
    let x = option.unwrap();
    foo(x);
}
```

è¿™ä¸¤ç§é€‰é¡¹éƒ½ä¸æ˜¯ç‰¹åˆ«å¸å¼•äººã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`if let`æ¥ä¼˜é›…åœ°å®Œæˆç›¸åŒçš„åŠŸèƒ½ï¼š

```rust
# let option = Some(5);
# fn foo(x: i32) { }
if let Some(x) = option {
    foo(x);
}
```

å¦‚æœä¸€ä¸ª[æ¨¡å¼](Patterns æ¨¡å¼.md)åŒ¹é…æˆåŠŸï¼Œå®ƒç»‘å®šä»»ä½•å€¼çš„åˆé€‚çš„éƒ¨åˆ†åˆ°æ¨¡å¼çš„æ ‡è¯†ç¬¦ä¸­ï¼Œå¹¶è®¡ç®—è¿™ä¸ªè¡¨è¾¾å¼ã€‚å¦‚æœæ¨¡å¼ä¸åŒ¹é…ï¼Œå•¥ä¹Ÿä¸ä¼šå‘ç”Ÿã€‚

å¦‚æœä½ æƒ³åœ¨æ¨¡å¼ä¸åŒ¹é…æ—¶åšç‚¹å…¶ä»–çš„ï¼Œä½ å¯ä»¥ä½¿ç”¨`else`ï¼š

```rust
# let option = Some(5);
# fn foo(x: i32) { }
# fn bar() { }
if let Some(x) = option {
    foo(x);
} else {
    bar();
}
```

## `while let`
ç±»ä¼¼çš„ï¼Œå½“ä½ æƒ³ä¸€ç›´å¾ªç¯ï¼Œç›´åˆ°ä¸€ä¸ªå€¼åŒ¹é…åˆ°ç‰¹å®šçš„æ¨¡å¼çš„æ—¶å€™ï¼Œä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨`while let`ã€‚ä½¿ç”¨`while let`å¯ä»¥æŠŠç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š

```rust
let mut v = vec![1, 3, 5, 7, 11];
loop {
    match v.pop() {
        Some(x) =>  println!("{}", x),
        None => break,
    }
}
```

å˜æˆè¿™æ ·çš„ä»£ç ï¼š

```rust
let mut v = vec![1, 3, 5, 7, 11];
while let Some(x) = v.pop() {
    println!("{}", x);
}
```
